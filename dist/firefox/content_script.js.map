{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/scripts/content_script.ts"],"names":[],"mappings":"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","file":"content_script.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/scripts/content_script.ts\");\n","/**\n * Runs on every open tab.\n * Handles identification of forms on the webpage, tracks submission of those\n * forms and fills forms when credentials are received from another script\n * using the extension message API.\n * */\n\n/**\n * Describes the purpose of the form. Some forms should be filled while others\n * should be ignored or handled as special cases.\n * */\nenum FormType {\n  Login = 'login',\n  Card = 'card',\n  Search = 'search',\n  ContactInfo = 'contactinfo',\n  NewsLetter = 'newsletter',\n  Register = 'register',\n  Unknown = 'unknown'\n}\n\n/**\n * Matcher for an input field.\n * @param type - Regular expression matching the input type attribute.\n * @param name - Regular expression matching the input name or id attribute.\n * */\ninterface Matcher {\n  type: RegExp;\n  name: RegExp;\n}\n\n/**\n * Matcher for forms to determine the type of the form.\n * @param name - Regular expression matching the name or id attribute of the form.\n * @param role - Regular expression matching the role attribute of the form.\n * @param fields - List of matchers for the input fields inside the form.\n * */\ninterface FormMatcher {\n  name: RegExp;\n  role?: RegExp;\n  fields: Matcher[];\n}\n\n/**\n * Keys should match field names in StoredSafe, form inputs should only be filled\n * with the corresponding StoredSafe data if both type and name (name or id attribute)\n * get a match.\n * */\nconst matchers: Map<string, Matcher> = new Map([\n  ['username', {\n    type: /text|email/,\n    name: /user|name|mail/,\n  }],\n  ['password', {\n    type: /password/,\n    name: /.*/,\n  }],\n  ['cardno', {\n    type: /text|tel/,\n    name: /card/,\n  }],\n  ['expires', {\n    type: /text|tel/,\n    name: /exp/,\n  }],\n  ['cvc', {\n    type: /text|tel/,\n    name: /sec|code|cvv|cvc/,\n  }],\n]);\n\n/**\n * Matching the form name is considered a definite match and should return the form type.\n * Not matching a name means the fields fallback should be checked.\n * If using the fields fallback, the form should only be considered a match if all field\n * matchers find a match.\n * The formMatchers will be checked in order of appearance and the first match if any will\n * be used, meaning more generic matchers should be placed further down in the list.\n * */\nconst formMatchers: Map<FormType, FormMatcher> = new Map([\n  [FormType.Search, {\n    name: /search/,\n    role: /search/,\n    fields: [{\n      type: /text|search/,\n      name: /search/,\n    }],\n  }],\n  [FormType.Register, {\n    name: /reg|signup/,\n    fields: [{\n      type: /password/,\n      name: /re/,\n    }],\n  }],\n  [FormType.Login, {\n    name: /login/,\n    fields: [\n      matchers.get('username'),\n      matchers.get('password'),\n    ],\n  }],\n  [FormType.NewsLetter, {\n    name: /news|letter/,\n    fields: [],\n  }],\n]);\n\n/**\n * Checks whether an element is of a type that is fillable by the user.\n * @param element Element to be tested.\n * @returns True if the element is an input that can be filled by the user.\n * */\nfunction isElementFillable(element: Element): boolean {\n  return element instanceof HTMLInputElement && ![\n    'hidden',\n    'button',\n    'submit',\n    'reset'\n  ].includes(element.type);\n}\n\n/**\n * Checks whether a field is a match for the provded input field.\n * @param field - Name of StoredSafe field.\n * @param element - Input element to attempt a match with.\n * @returns True if the element is a match for the field.\n * */\nfunction isMatch(\n  field: string,\n  element: HTMLInputElement\n): boolean {\n  if (matchers.get(field) === undefined) return false;\n  const types = new RegExp(matchers.get(field).type, 'i');\n  const name = new RegExp(matchers.get(field).name, 'i');\n  return (\n    types.test(element.type) && ( name.test(element.name) || name.test(element.id))\n  );\n}\n\n/**\n * Checks a form against the form matchers to determine the type of the form.\n * @param form - The form to be matched.\n * @returns The type indicating the purpose of the form.\n * */\nfunction getFormType(form: HTMLFormElement): FormType {\n  for(const [formType, formTypeMatchers] of formMatchers) {\n\n    // Check for form name or id match\n    const name = new RegExp(formTypeMatchers.name, 'i');\n    if (name.test(form.id) || name.test(form.name)) {\n      return formType;\n    }\n\n    // Check for form role\n    const formRole = form.attributes.getNamedItem('role');\n    if (formTypeMatchers.role && formRole) {\n      const role = new RegExp(formTypeMatchers.role, 'i');\n      if (role.test(formRole.value)) {\n        return formType;\n      }\n    }\n\n    // Check for fields match\n    let match = formTypeMatchers.fields.length === 0 ? false : true;\n    for(let i = 0; i < formTypeMatchers.fields.length; i++) {\n      const fieldName = new RegExp(formTypeMatchers.fields[i].name, 'i');\n      const fieldType = new RegExp(formTypeMatchers.fields[i].type, 'i');\n      let fieldMatch = false;\n      for(let j = 0; j < form.length; j++) {\n        const element = form[j];\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement) {\n          if (fieldType.test(element.type) && (fieldName.test(element.id) || fieldName.test(element.name))) {\n            fieldMatch = true;\n          }\n        }\n      }\n      // Overall match only if all fields find a matching element.\n      match = match && fieldMatch;\n    }\n    if (match) return formType;\n  }\n  return FormType.Unknown;\n}\n\n/**\n * Form types that should be filled by the extension.\n * */\nconst fillFormTypes: FormType[] = [\n  FormType.Login,\n  FormType.Card,\n];\n\n/**\n * Form types that should be saved by the extension when the form is submitted.\n * */\nconst saveFormTypes: FormType[] = [\n  FormType.Login,\n  FormType.Register,\n];\n\nlet fillForms: HTMLFormElement[] = [];\n/**\n * Scan the webpage for forms and identify the types of those forms.\n * If any fillable forms are found, send a message to the background script to\n * perform a search.\n * If any forms are of a type where we want to save the data they submit, set\n * up an event handler to send the data to the background script when submitted.\n * */\nfunction scanPage(): void {\n  const { forms } = document;\n  fillForms = [];\n  for(let i = 0; i < forms.length; i++) {\n    const formType = getFormType(forms[i]);\n    // console.log(formType, forms[i]);\n    if (fillFormTypes.includes(formType)) {\n      // console.log('Adding form to fillable: ', forms[i]);\n      fillForms.push(forms[i]);\n    }\n    if (saveFormTypes.includes(formType)) {\n      // console.log('Attaching submit handler to: ', forms[i]);\n      forms[i].addEventListener('submit', (event) => {\n        const values: Record<string, string> = {};\n        const target = event.target as HTMLFormElement;\n        for (const [field] of matchers) {\n          for (let i = 0; i < target.length; i++) {\n            const element = target[i];\n            if (element instanceof HTMLInputElement && isMatch(field, element)) {\n              // console.log(field, element.value);\n              values[field] = element.value;\n            }\n          }\n        }\n        browser.runtime.sendMessage({ type: 'submit', data: values })\n      });\n    }\n  }\n\n  if (fillForms.length > 0) {\n    browser.runtime.sendMessage({\n      type: 'tabSearch',\n    });\n  }\n}\n\n// Scan page when the content script is loaded.\nscanPage();\n\n// Observe changes in the webpage in case there are forms that are not rendered\n// when the DOM is first loaded.\n// TODO: Fix looping when other extensions change the form\n// const observer = new MutationObserver((mutation) => {\n  // console.log(mutation);\n  // for (const { addedNodes } of mutation) {\n    // console.log(addedNodes);\n  // }\n  // //scanPage()\n// });\n// observer.observe(document.body, { childList: true });\n\n/**\n * Mapping of StoredSafe field names to StoredSafe values.\n * */\ntype Data = [string, string][];\n\n/**\n * Fill input fields with StoredSafe data in the appropriate forms/fields.\n * @param data - StoredSafe data.\n * @param submit - Whether or not to submit the form after filling it.\n * */\nfunction fillForm(data: Data, submit=false): void {\n  for (const form of fillForms) {\n    let filled = false;\n    for (const element of form) {\n      if (element instanceof HTMLInputElement && isElementFillable(element)) {\n        let elementFilled = false;\n        for (const [field, value] of new Map(data)) {\n          // console.log('Attempting to fill', field, 'in', element);\n          if (isMatch(field, element)) {\n            // console.log('Filled field', field);\n            elementFilled = true;\n            filled = true;\n            element.value = value;\n            break;\n          }\n        }\n        if (!elementFilled) { // If no field matched this element\n          // console.log('Focus unfilled element', element);\n          element.focus(); // Focus element for easier access (example otp field)\n        }\n      }\n    }\n    if (filled && submit) {\n      // fillForms[i].submit(); // TODO: Fix compatibility with autofill on failed login.\n    }\n  }\n}\n\n/**\n * The type of messages the content script expects to receive.\n * @param type - The type of the message, contract between sender and receiver.\n * @param data - StoredSafe data.\n * */\ninterface Message {\n  type: string;\n  data: Data;\n}\n\n/**\n * Handle messages sent to the tab by other scripts.\n * @param message - Message sent by other script.\n * */\nfunction onMessage(\n  message: Message,\n): void {\n  if (message.type === 'fill') {\n    fillForm(message.data);\n  }\n}\n\n// Set up listener for messages from other scripts within the extension.\nbrowser.runtime.onMessage.addListener(onMessage);\n"],"sourceRoot":""}