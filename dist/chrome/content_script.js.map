{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/scripts/content_script.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","FormType","matchers","Map","type","formMatchers","Search","role","fields","Register","Login","NewsLetter","isMatch","field","element","undefined","types","RegExp","test","id","getFormType","form","formType","formTypeMatchers","formRole","attributes","getNamedItem","match","length","fieldName","fieldType","fieldMatch","j","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","Unknown","fillFormTypes","Card","saveFormTypes","fillForms","setup","forms","document","console","log","includes","push","addEventListener","event","values","target","set","browser","runtime","sendMessage","Array","from","MutationObserver","observe","body","childList","onMessage","addListener","message","data","filled","elementFilled","keys","forEach","focus"],"mappings":"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","file":"content_script.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 167);\n","// const types = /text|url|password|email/i;\n// const ids = /user|name|pass|mail|url|server|site/i;\n\nenum FormType {\n  Login = 'login',\n  Card = 'card',\n  Search = 'search',\n  ContactInfo = 'contactinfo',\n  NewsLetter = 'newsletter',\n  Register = 'register',\n  Unknown = 'unknown',\n}\n\ninterface Matcher {\n  type: RegExp;\n  name: RegExp;\n}\n\ninterface FormMatcher {\n  name: RegExp;\n  role?: RegExp;\n  fields: Matcher[];\n}\n\n/**\n * Keys should match field names in StoredSafe, form inputs should only be filled\n * with the corresponding StoredSafe data if both type and name (name or id attribute)\n * get a match.\n * */\nconst matchers: Map<string, Matcher> = new Map([\n  ['username', {\n    type: /text|email/,\n    name: /user|name|mail/,\n  }],\n  ['password', {\n    type: /password/,\n    name: /.*/,\n  }],\n  ['cardno', {\n    type: /text|tel/,\n    name: /card/,\n  }],\n  ['expires', {\n    type: /text|tel/,\n    name: /exp/,\n  }],\n  ['cvc', {\n    type: /text|tel/,\n    name: /sec|code|cvv|cvc/,\n  }],\n]);\n\n/**\n * Matching the form name is considered a definite match and should return the form type,\n * not matching a name means the fields fallback should be checked.\n * If using the fields fallback, the form should only be considered a match if all fields\n * matchers find a match.\n * The formMatchers will be checked in order of appearance and the first match if any will\n * be used, meaning more generic matchers should be placed further down in the list.\n * */\nconst formMatchers: Map<FormType, FormMatcher> = new Map([\n  [FormType.Search, {\n    name: /search/,\n    role: /search/,\n    fields: [{\n      type: /text|search/,\n      name: /search/,\n    }],\n  }],\n  [FormType.Register, {\n    name: /reg|signup/,\n    fields: [{\n      type: /password/,\n      name: /re/,\n    }],\n  }],\n  [FormType.Login, {\n    name: /login/,\n    fields: [\n      matchers.get('username'),\n      matchers.get('password'),\n    ],\n  }],\n  [FormType.NewsLetter, {\n    name: /news|letter/,\n    fields: [],\n  }],\n]);\n\nfunction isMatch(\n  field: string,\n  element: HTMLInputElement\n): boolean {\n  if (matchers.get(field) === undefined) return false;\n  const types = new RegExp(matchers.get(field).type, 'i');\n  const name = new RegExp(matchers.get(field).name, 'i');\n  return (\n    types.test(element.type) && ( name.test(element.name) || name.test(element.id))\n  );\n}\n\nfunction getFormType(form: HTMLFormElement): FormType {\n  for(const [formType, formTypeMatchers] of formMatchers) {\n\n    // Check for form name or id match\n    const name = new RegExp(formTypeMatchers.name, 'i');\n    if (name.test(form.id) || name.test(form.name)) {\n      return formType;\n    }\n\n    // Check for form role\n    const formRole = form.attributes.getNamedItem('role');\n    if (formTypeMatchers.role && formRole) {\n      const role = new RegExp(formTypeMatchers.role, 'i');\n      if (role.test(formRole.value)) {\n        return formType;\n      }\n    }\n\n    // Check for fields match\n    let match = formTypeMatchers.fields.length === 0 ? false : true;\n    for(let i = 0; i < formTypeMatchers.fields.length; i++) {\n      const fieldName = new RegExp(formTypeMatchers.fields[i].name, 'i');\n      const fieldType = new RegExp(formTypeMatchers.fields[i].type, 'i');\n      let fieldMatch = false;\n      for(let j = 0; j < form.length; j++) {\n        const element = form[j];\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement) {\n          if (fieldType.test(element.type) && (fieldName.test(element.id) || fieldName.test(element.name))) {\n            fieldMatch = true;\n          }\n        }\n      }\n      // Overall match only if all fields find a matching element.\n      match = match && fieldMatch;\n    }\n    if (match) return formType;\n  }\n  return FormType.Unknown;\n}\n\nconst fillFormTypes: FormType[] = [\n  FormType.Login,\n  FormType.Card,\n];\n\nconst saveFormTypes: FormType[] = [\n  FormType.Login,\n  FormType.Register,\n];\n\nlet fillForms: HTMLFormElement[] = [];\nfunction setup(): void {\n  const { forms } = document;\n  fillForms = [];\n  for(let i = 0; i < forms.length; i++) {\n    const formType = getFormType(forms[i]);\n    console.log(formType, forms[i]);\n    if (fillFormTypes.includes(formType)) {\n      console.log('Adding form to fillable: ', forms[i]);\n      fillForms.push(forms[i]);\n    }\n    if (saveFormTypes.includes(formType)) {\n      console.log('Attaching submit handler to: ', forms[i]);\n      forms[i].addEventListener('submit', (event) => {\n        const values: Map<string, string> = new Map();\n        const target = event.target as HTMLFormElement;\n        for (const [field] of matchers) {\n          for (let i = 0; i < target.length; i++) {\n            const element = target[i];\n            if (element instanceof HTMLInputElement && isMatch(field, element)) {\n              console.log(field, element.value);\n              values.set(field, element.value);\n            }\n          }\n        }\n        browser.runtime.sendMessage({ type: 'submit', values: Array.from(values) })\n      });\n    }\n  }\n\n  if (fillForms.length > 0) {\n    browser.runtime.sendMessage({\n      type: 'tabSearch',\n    });\n  }\n}\n\nsetup();\nconst observer = new MutationObserver((m, o) => { console.log(m, o); setup() });\nobserver.observe(document.body, { childList: true });\n\ninterface Message {\n  type: string;\n  data: {\n    [field: string]: string;\n  };\n}\n\nfunction onMessage(\n  message: Message,\n): void {\n  if (message.type === 'fill') {\n    console.log(message.data);\n    for (let i = 0; i < fillForms.length; i++) {\n      let filled = false;\n      for (let j = 0; j < fillForms[i].length; j++) {\n        const element = fillForms[i][j];\n        if (element instanceof HTMLInputElement) {\n          let elementFilled = false;\n          Object.keys(message.data).forEach((field) => {\n            console.log('Attempting to fill', field, 'in', element);\n            if (isMatch(field, element)) {\n              console.log('Filled field', field);\n              elementFilled = true;\n              filled = true;\n              element.value = message.data[field];\n              return;\n            }\n          });\n          if (!elementFilled) { // If no field matched this element\n            if (!['hidden', 'button', 'submit', 'reset'].includes(element.type)) {\n              console.log('Focus unfilled element', element);\n              element.focus(); // Focus element for easier access (example otp field)\n            }\n          }\n        }\n      }\n      if (filled) {\n        // fillForms[i].submit(); // TODO: Fix compatibility with autofill on failed login.\n      }\n    }\n  }\n}\n\nbrowser.runtime.onMessage.addListener(onMessage);\n"],"sourceRoot":""}